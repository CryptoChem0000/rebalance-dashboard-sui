name: Deploy CLAMM Bots

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag to deploy (e.g., sha-abc1234, v1.0.0, latest)"
        required: true
        type: string
        default: "latest"
      environments:
        description: "Comma-separated list of environments (empty = all bots)"
        required: false
        default: ""
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  PROJECT_ID: ${{ secrets.GKE_PROJECT }}
  GKE_CLUSTER: shared-gke-nonprod
  GKE_REGION: us-central1
  HELM_CHART_PATH: ./charts

defaults:
  run:
    shell: bash

jobs:
  resolve-tag:
    runs-on: ubuntu-latest
    outputs:
      resolved_tag: ${{ steps.resolve.outputs.tag }}
      is_latest: ${{ steps.resolve.outputs.is_latest }}

    steps:
      - name: Resolve image tag
        id: resolve
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          INPUT_TAG="${{ github.event.inputs.image_tag }}"

          if [ "$INPUT_TAG" = "latest" ]; then
            echo "üìã 'latest' tag requested, fetching actual latest version..."
            
            # Get the latest release tag
            LATEST_TAG=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/releases/latest \
              --jq '.tag_name' 2>/dev/null || echo "")
            
            if [ -z "$LATEST_TAG" ]; then
              echo "No releases found, checking for latest tag..."
              # Fallback to git tags if no releases
              LATEST_TAG=$(gh api \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                /repos/${{ github.repository }}/tags \
                --jq '.[0].name' 2>/dev/null || echo "")
            fi
            
            if [ -z "$LATEST_TAG" ]; then
              echo "::error::No tags found in repository. Cannot determine latest version."
              exit 1
            fi
            
            # Strip 'v' prefix if present for Docker tags
            DOCKER_TAG="${LATEST_TAG#v}"
            
            echo "‚úÖ Latest version found: $LATEST_TAG"
            echo "‚úÖ Docker tag to use: $DOCKER_TAG"
            echo "tag=$DOCKER_TAG" >> $GITHUB_OUTPUT
            echo "is_latest=true" >> $GITHUB_OUTPUT
          else
            # Strip 'v' prefix if present for any manual input
            DOCKER_TAG="${INPUT_TAG#v}"
            echo "‚úÖ Using specified tag: $INPUT_TAG"
            echo "‚úÖ Docker tag to use: $DOCKER_TAG"
            echo "tag=$DOCKER_TAG" >> $GITHUB_OUTPUT
            echo "is_latest=false" >> $GITHUB_OUTPUT
          fi

  setup:
    runs-on: ubuntu-latest
    needs: [resolve-tag]
    outputs:
      environments: ${{ steps.output-matrix.outputs.environments }}
      deployment_type: ${{ steps.determine-type.outputs.type }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate deployment request
        run: |
          # Use resolved tag instead of input
          echo "üîç Will deploy image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.resolve-tag.outputs.resolved_tag }}"

          if [ "${{ needs.resolve-tag.outputs.is_latest }}" = "true" ]; then
            echo "üìå 'latest' was requested, resolved to version: ${{ needs.resolve-tag.outputs.resolved_tag }}"
          fi

      - name: Get available environments from GitHub
        id: get-github-envs
        uses: actions/github-script@v6
        with:
          script: |
            try {
              const { data: environments } = await github.rest.repos.getAllEnvironments({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              
              // Get ALL environments
              const allEnvs = environments.environments.map(env => env.name);
              
              console.log('Available GitHub environments:', allEnvs);
              
              if (allEnvs.length === 0) {
                core.setFailed('No GitHub environments found. Please create at least one environment.');
                return;
              }
              
              core.setOutput('github_environments', JSON.stringify(allEnvs));
            } catch (error) {
              core.setFailed(`Failed to fetch GitHub environments: ${error.message}`);
            }

      - name: Determine environments to deploy
        id: determine-envs
        run: |
          set -euo pipefail

          GITHUB_ENVS='${{ steps.get-github-envs.outputs.github_environments }}'

          if [ -z "$GITHUB_ENVS" ] || [ "$GITHUB_ENVS" = "null" ]; then
            echo "::error::No GitHub environments data available"
            exit 1
          fi

          echo "GitHub CLAMM bot environments: $GITHUB_ENVS"

          # Determine which environments to deploy
          if [ -n "${{ github.event.inputs.environments }}" ]; then
            # Use specified environments
            REQUESTED_ENVS="${{ github.event.inputs.environments }}"
            IFS=',' read -ra ENVS_ARRAY <<< "$REQUESTED_ENVS"
            
            # Validate requested environments exist
            VALID_ENVS=()
            INVALID_ENVS=()
            for env in "${ENVS_ARRAY[@]}"; do
              env=$(echo "$env" | xargs) # Trim whitespace
              if echo "$GITHUB_ENVS" | jq -e ".[] | select(. == \"$env\")" > /dev/null 2>&1; then
                VALID_ENVS+=("$env")
                echo "‚úÖ $env: Found in GitHub environments"
              else
                INVALID_ENVS+=("$env")
                echo "‚ùå $env: Not found in GitHub environments"
              fi
            done
            
            # If any requested environment is invalid, fail
            if [ ${#INVALID_ENVS[@]} -gt 0 ]; then
              echo "::error::Invalid environments requested: ${INVALID_ENVS[*]}"
              echo "::error::Available environments are: $(echo "$GITHUB_ENVS" | jq -r '.[]' | tr '\n' ' ')"
              exit 1
            fi
          else
            # Deploy all environments
            VALID_ENVS=($(echo "$GITHUB_ENVS" | jq -r '.[]'))
            echo "No specific environments requested - will process all environments"
          fi

          # Save valid environments
          if [ ${#VALID_ENVS[@]} -eq 0 ]; then
            echo "::error::No valid environments found to deploy"
            exit 1
          fi

          printf '%s\n' "${VALID_ENVS[@]}" > valid-envs.txt
          echo "Total environments to process: ${#VALID_ENVS[@]}"

      - name: Validate DATABASE_URL repository secret exists
        run: |
          if [ -z "${{ secrets.DATABASE_URL }}" ]; then
            echo "::error::DATABASE_URL repository secret not found"
            echo "Please add the DATABASE_URL secret to the repository secrets"
            exit 1
          fi
          echo "‚úÖ DATABASE_URL repository secret found"

      - name: Create matrix output
        id: output-matrix
        run: |
          set -euo pipefail

          if [ ! -f valid-envs.txt ]; then
            echo "::error::valid-envs.txt file not found"
            exit 1
          fi

          VALID_ENVS=()
          while IFS= read -r line; do
            [ -n "$line" ] && VALID_ENVS+=("$line")
          done < valid-envs.txt

          if [ ${#VALID_ENVS[@]} -eq 0 ]; then
            echo "::error::No environments found in valid-envs.txt"
            exit 1
          fi

          # Create JSON array using jq with compact output
          JSON=$(printf '%s\n' "${VALID_ENVS[@]}" | jq -R . | jq -s -c .)

          # Validate JSON
          if ! echo "$JSON" | jq . > /dev/null 2>&1; then
            echo "::error::Failed to create valid JSON matrix"
            exit 1
          fi

          echo "Matrix JSON: $JSON"

          echo "environments<<EOF" >> $GITHUB_OUTPUT
          echo "$JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  deploy:
    needs: [setup, resolve-tag]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJson(needs.setup.outputs.environments) }}
      fail-fast: false
    environment: ${{ matrix.environment }}
    continue-on-error: true

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check if bot is enabled
        id: check-enabled
        run: |
          ENABLED="${{ vars.ENABLED }}"
          if [ -z "$ENABLED" ]; then
            echo "ENABLED variable not set, defaulting to false"
            ENABLED="false"
          fi

          echo "ENABLED=$ENABLED" >> $GITHUB_OUTPUT
          echo "Bot ${{ matrix.environment }} enabled: $ENABLED"

      - name: Validate required variables and secrets
        if: steps.check-enabled.outputs.ENABLED == 'true'
        run: |
          set -euo pipefail

          CRITICAL_ERROR=false

          # Check secrets
          if [ -z "${{ secrets.MNEMONIC }}" ]; then
            echo "::error::MNEMONIC secret not found in environment ${{ matrix.environment }}"
            CRITICAL_ERROR=true
          else
            echo "‚úÖ MNEMONIC secret found"
          fi

          # Check variables
          MISSING_VARS=()

          if [ -z "${{ vars.POOL_ID }}" ]; then
            MISSING_VARS+=("POOL_ID")
          fi

          if [ -z "${{ vars.REBALANCE_THRESHOLD_PERCENT }}" ]; then
            MISSING_VARS+=("REBALANCE_THRESHOLD_PERCENT")
          fi

          if [ -z "${{ vars.POSITION_BAND_PERCENTAGE }}" ]; then
            MISSING_VARS+=("POSITION_BAND_PERCENTAGE")
          fi

          if [ -z "${{ vars.WATCH_FREQUENCY }}" ]; then
            MISSING_VARS+=("WATCH_FREQUENCY")
          fi

          if [ ${#MISSING_VARS[@]} -gt 0 ]; then
            echo "::error::Missing required variables in environment ${{ matrix.environment }}: ${MISSING_VARS[*]}"
            echo "::error::Please add these variables to the GitHub environment: ${{ matrix.environment }}"
            CRITICAL_ERROR=true
          fi

          if [ "$CRITICAL_ERROR" = "true" ]; then
            echo "::error::Critical configuration errors found for ${{ matrix.environment }}"
            exit 1
          fi

          echo "‚úÖ All required variables found"
          echo "Configuration for ${{ matrix.environment }}:"
          echo "  POOL_ID: ${{ vars.POOL_ID }}"
          echo "  REBALANCE_THRESHOLD_PERCENT: ${{ vars.REBALANCE_THRESHOLD_PERCENT }}"
          echo "  POSITION_BAND_PERCENTAGE: ${{ vars.POSITION_BAND_PERCENTAGE }}"
          echo "  WATCH_FREQUENCY: ${{ vars.WATCH_FREQUENCY }}"

      - id: "auth"
        uses: "google-github-actions/auth@v2"
        with:
          credentials_json: "${{ secrets.GKE_PROD_SA_KEY }}"

      - name: Setup Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GKE_PROJECT }}

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_REGION }}

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: "3.19.0"

      - name: Deploy or stop bot based on ENABLED status
        env:
          IMAGE_TAG: ${{ needs.resolve-tag.outputs.resolved_tag }}
          DEPLOYMENT_NAME: ${{ matrix.environment }}
          NAMESPACE: bolt-prod
          ENABLED: ${{ steps.check-enabled.outputs.ENABLED }}
          # Repository secrets
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          # Environment secrets
          MNEMONIC: ${{ secrets.MNEMONIC }}
          # Environment variables
          POOL_ID: ${{ vars.POOL_ID }}
          REBALANCE_THRESHOLD_PERCENT: ${{ vars.REBALANCE_THRESHOLD_PERCENT }}
          POSITION_BAND_PERCENTAGE: ${{ vars.POSITION_BAND_PERCENTAGE }}
          WATCH_FREQUENCY: ${{ vars.WATCH_FREQUENCY }}
          CHAIN: ${{ vars.CHAIN }}

        run: |
          if [ "$ENABLED" == "true" ]; then
            echo "üöÄ Deploying $DEPLOYMENT_NAME..."
            echo "Using image tag: $IMAGE_TAG"
            echo "Pool ID: $POOL_ID"
            echo "Rebalance Threshold: $REBALANCE_THRESHOLD_PERCENT%"
            echo "Position Band: $POSITION_BAND_PERCENTAGE%"
            echo "Chain: $CHAIN"
            echo "Watch Frequency: $WATCH_FREQUENCY seconds"

            # Base64 encode the values
            export DATABASE_URL_B64=$(echo -n "$DATABASE_URL" | base64)
            export MNEMONIC_B64=$(echo -n "$MNEMONIC" | base64)
            export POOL_ID_B64=$(echo -n "$POOL_ID" | base64)
            export REBALANCE_THRESHOLD_PERCENT_B64=$(echo -n "$REBALANCE_THRESHOLD_PERCENT" | base64)
            export POSITION_BAND_PERCENTAGE_B64=$(echo -n "$POSITION_BAND_PERCENTAGE" | base64)
            export WATCH_FREQUENCY_B64=$(echo -n "$WATCH_FREQUENCY" | base64)
            export CHAIN_B64=$(echo -n "$CHAIN" | base64)

            # Check current state before deployment
            echo "üìä Pre-deployment state:"
            kubectl get deployment -n $NAMESPACE | grep -E "(NAME|$DEPLOYMENT_NAME)" || echo "No matching deployments found"
            
            # Deploy using Helm without --wait first
            echo "üîß Starting Helm upgrade at $(date)..."
            helm upgrade --install $DEPLOYMENT_NAME $HELM_CHART_PATH \
              --namespace $NAMESPACE \
              --create-namespace \
              --set image.repository=${REGISTRY}/${IMAGE_NAME} \
              --set image.tag=$IMAGE_TAG \
              --set replicaCount=1 \
              --set secrets.app-secrets.data.DATABASE_URL="$DATABASE_URL_B64" \
              --set secrets.app-secrets.data.MNEMONIC="$MNEMONIC_B64" \
              --set secrets.app-secrets.data.POOL_ID="$POOL_ID_B64" \
              --set secrets.app-secrets.data.REBALANCE_THRESHOLD_PERCENT="$REBALANCE_THRESHOLD_PERCENT_B64" \
              --set secrets.app-secrets.data.POSITION_BAND_PERCENTAGE="$POSITION_BAND_PERCENTAGE_B64" \
              --set secrets.app-secrets.data.CHAIN="$CHAIN_B64" \
              --set secrets.app-secrets.data.WATCH_FREQUENCY="$WATCH_FREQUENCY_B64" \
              --values ./charts/values.yaml \
              --debug

            echo "‚úÖ Helm command completed at $(date)"

            # Give it a moment to create resources
            sleep 3

            # Check what Helm created
            echo "üìä Post-Helm state:"
            kubectl get all -n $NAMESPACE -l app.kubernetes.io/instance=$DEPLOYMENT_NAME

            # Figure out the actual deployment name
            echo "üîç Looking for deployment..."
            ACTUAL_DEPLOYMENT_NAME=""
            if kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE &> /dev/null; then
              ACTUAL_DEPLOYMENT_NAME=$DEPLOYMENT_NAME
              echo "Found deployment: $DEPLOYMENT_NAME"
            elif kubectl get deployment ${DEPLOYMENT_NAME}-clamm-bot -n $NAMESPACE &> /dev/null; then
              ACTUAL_DEPLOYMENT_NAME=${DEPLOYMENT_NAME}-clamm-bot
              echo "Found deployment: ${DEPLOYMENT_NAME}-clamm-bot"
            else
              echo "‚ö†Ô∏è  No deployment found with expected names"
              echo "All deployments in namespace:"
              kubectl get deployments -n $NAMESPACE
            fi

            if [ -n "$ACTUAL_DEPLOYMENT_NAME" ]; then
              # Check deployment details
              echo "üìã Deployment details:"
              kubectl describe deployment $ACTUAL_DEPLOYMENT_NAME -n $NAMESPACE | grep -A 5 -E "(Replicas:|Conditions:|NewReplicaSet:)"

              # Check for pods
              echo "üìä Pod status:"
              kubectl get pods -l app.kubernetes.io/instance=$DEPLOYMENT_NAME -n $NAMESPACE -o wide

              # Wait for rollout with detailed status
              echo "‚è≥ Waiting for initial rollout to complete..."
              if ! kubectl rollout status deployment/${ACTUAL_DEPLOYMENT_NAME} -n $NAMESPACE --timeout=300s; then
                echo "‚ùå Initial rollout failed/timed out"
                
                # Get debugging info
                echo "üîç Debugging pod issues:"
                
                # Get pod events
                echo "Pod events:"
                kubectl get events -n $NAMESPACE --field-selector involvedObject.kind=Pod --sort-by='.lastTimestamp' | grep -i $DEPLOYMENT_NAME | tail -20
                
                # Describe pods
                echo "Pod descriptions:"
                kubectl describe pods -l app.kubernetes.io/instance=$DEPLOYMENT_NAME -n $NAMESPACE
                
                # Check logs if any pods exist
                PODS=$(kubectl get pods -l app.kubernetes.io/instance=$DEPLOYMENT_NAME -n $NAMESPACE -o jsonpath='{.items[*].metadata.name}')
                for pod in $PODS; do
                  echo "Logs from pod $pod:"
                  kubectl logs $pod -n $NAMESPACE --tail=50 || echo "Failed to get logs"
                done
                
                exit 1
              fi

              # Now do the restart
              echo "üîÑ Forcing pod restart at $(date)..."
              kubectl rollout restart deployment/${ACTUAL_DEPLOYMENT_NAME} -n $NAMESPACE
              kubectl rollout status deployment/${ACTUAL_DEPLOYMENT_NAME} -n $NAMESPACE --timeout=300s

              echo "‚úÖ Successfully deployed $DEPLOYMENT_NAME with image $IMAGE_TAG at $(date)"
            else
              echo "‚ö†Ô∏è  Warning: Could not find deployment to monitor"
              echo "‚úÖ Helm deployment completed for $DEPLOYMENT_NAME"
            fi
         
          else
            echo "‚è∏Ô∏è  Bot $DEPLOYMENT_NAME is disabled (ENABLED=$ENABLED)"
            
            # Check if deployment exists (try both naming patterns)
            FOUND_DEPLOYMENT=""
            
            if kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE &> /dev/null; then
              FOUND_DEPLOYMENT=$DEPLOYMENT_NAME
            elif kubectl get deployment ${DEPLOYMENT_NAME}-clamm-bot -n $NAMESPACE &> /dev/null; then
              FOUND_DEPLOYMENT=${DEPLOYMENT_NAME}-clamm-bot
            fi
            
            if [ -n "$FOUND_DEPLOYMENT" ]; then
              echo "Scaling down existing deployment $FOUND_DEPLOYMENT to 0 replicas..."
              
              kubectl scale deployment $FOUND_DEPLOYMENT --replicas=0 -n $NAMESPACE
              
              kubectl label deployment $FOUND_DEPLOYMENT -n $NAMESPACE enabled=false --overwrite
              kubectl annotate deployment $FOUND_DEPLOYMENT -n $NAMESPACE disabled-at="$(date -u +%Y-%m-%dT%H:%M:%SZ)" --overwrite
              kubectl annotate deployment $FOUND_DEPLOYMENT -n $NAMESPACE disabled-reason="ENABLED variable set to false" --overwrite
              
              echo "‚úÖ Deployment $FOUND_DEPLOYMENT scaled to 0 replicas (resources preserved)"
            else
              echo "‚ÑπÔ∏è  No existing deployment found to stop"
            fi
          fi

      - name: Verify deployment status
        env:
          NAMESPACE: bolt-prod
        run: |
          echo "Checking deployment status..."

          # Try both possible deployment names
          DEPLOYMENT_NAME="${{ matrix.environment }}"
          ALT_DEPLOYMENT_NAME="${{ matrix.environment }}-clamm-bot"

          FOUND_DEPLOYMENT=""

          # Check standard name first
          if kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE &> /dev/null; then
            FOUND_DEPLOYMENT=$DEPLOYMENT_NAME
          # Check with -clamm-bot suffix
          elif kubectl get deployment $ALT_DEPLOYMENT_NAME -n $NAMESPACE &> /dev/null; then
            FOUND_DEPLOYMENT=$ALT_DEPLOYMENT_NAME
          fi

          if [ -n "$FOUND_DEPLOYMENT" ]; then
            echo "‚úÖ Found deployment: $FOUND_DEPLOYMENT"
            kubectl -n $NAMESPACE get deployment $FOUND_DEPLOYMENT
            
            REPLICAS=$(kubectl get deployment $FOUND_DEPLOYMENT -n $NAMESPACE -o jsonpath='{.spec.replicas}')
            if [ "$REPLICAS" -eq "0" ]; then
              echo "‚ÑπÔ∏è  Deployment exists but is scaled to 0 (disabled)"
            else
              echo ""
              echo "Pod status:"
              kubectl -n $NAMESPACE get pods -l app.kubernetes.io/instance=${{ matrix.environment }}
            fi
          else
            echo "‚ÑπÔ∏è  No deployment found (bot might be disabled)"
          fi

  summary:
    needs: [deploy, setup, resolve-tag]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Check for critical failures
        run: |
          if [ "${{ needs.setup.result }}" == "failure" ]; then
            echo "::error::Setup job failed - critical error in deployment"
            exit 1
          fi

          echo "‚úÖ Setup completed successfully"

      - name: Checkout repository
        uses: actions/checkout@v4

      - id: "auth"
        uses: "google-github-actions/auth@v2"
        with:
          credentials_json: "${{ secrets.GKE_PROD_SA_KEY }}"

      - name: Setup Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GKE_PROJECT }}

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_REGION }}

      - name: Generate deployment summary
        env:
          NAMESPACE: bolt-prod
        run: |
          echo "# üìä Deployment Summary"
          echo ""
          echo "**Requested Tag:** \`${{ github.event.inputs.image_tag }}\`"
          echo "**Deployed Tag:** \`${{ needs.resolve-tag.outputs.resolved_tag }}\`"

          if [ "${{ needs.resolve-tag.outputs.is_latest }}" = "true" ]; then
            echo "**Note:** 'latest' was resolved to \`${{ needs.resolve-tag.outputs.resolved_tag }}\`"
          fi

          echo "**Deployment Type:** ${{ needs.setup.outputs.deployment_type }}"
          echo ""

          # Get all deployments managed by this workflow
          echo "## All Managed Deployments:"
          echo ""
          echo "| Environment | Status | Replicas | Image Tag | Last Updated |"
          echo "|-------------|--------|----------|-----------|--------------|"

          # Get all deployments
          DEPLOYMENTS_JSON=$(kubectl get deployments -n $NAMESPACE -o json)

          # Get list of environments we manage
          VALID_ENVS='${{ needs.setup.outputs.environments }}'

          # Process each environment
          echo "$VALID_ENVS" | jq -r '.[]' | while read -r env_name; do
            # Check if deployment exists (try both naming patterns)
            DEPLOYMENT=$(echo "$DEPLOYMENTS_JSON" | jq -r ".items[] | select(.metadata.name == \"$env_name\" or .metadata.name == \"${env_name}-clamm-bot\")")
            
            if [ -n "$DEPLOYMENT" ]; then
              DEPLOYMENT_NAME=$(echo "$DEPLOYMENT" | jq -r '.metadata.name')
              REPLICAS=$(echo "$DEPLOYMENT" | jq -r '.spec.replicas')
              IMAGE_TAG=$(echo "$DEPLOYMENT" | jq -r '.spec.template.spec.containers[0].image | split(":")[1] // "unknown"')
              UPDATED=$(echo "$DEPLOYMENT" | jq -r '.metadata.annotations."disabled-at" // .metadata.creationTimestamp')
              STATUS=$([ "$REPLICAS" -eq "0" ] && echo "‚è∏Ô∏è Stopped" || echo "‚úÖ Running")
              
              echo "| $env_name | $STATUS | $REPLICAS | $IMAGE_TAG | $UPDATED |"
            else
              echo "| $env_name | ‚ùå Not Found | - | - | - |"
            fi
          done

          echo ""
          echo "## Summary:"

          # Count running and stopped deployments from our managed list
          RUNNING=0
          STOPPED=0
          NOT_FOUND=0

          echo "$VALID_ENVS" | jq -r '.[]' | while read -r env_name; do
            DEPLOYMENT=$(echo "$DEPLOYMENTS_JSON" | jq -r ".items[] | select(.metadata.name == \"$env_name\" or .metadata.name == \"${env_name}-clamm-bot\")")
            
            if [ -n "$DEPLOYMENT" ]; then
              REPLICAS=$(echo "$DEPLOYMENT" | jq -r '.spec.replicas')
              if [ "$REPLICAS" -eq "0" ]; then
                STOPPED=$((STOPPED + 1))
              else
                RUNNING=$((RUNNING + 1))
              fi
            else
              NOT_FOUND=$((NOT_FOUND + 1))
            fi
          done | tail -1  # Get final counts

          TOTAL=$(echo "$VALID_ENVS" | jq -r '. | length')

          echo "- Total environments: $TOTAL"
          echo "- Running deployments: $RUNNING"
          echo "- Stopped deployments: $STOPPED"
          echo "- Not deployed: $NOT_FOUND"
          echo ""

          if [ "${{ needs.setup.outputs.deployment_type }}" == "automatic" ]; then
            echo "ü§ñ *This deployment was automatically triggered by a build workflow*"
          fi
